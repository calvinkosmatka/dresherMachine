from __future__ import print_function
import math
import sys
import itertools
import re
import main_1inventoryMover as m
import dresher_LSA as d

class Language:
	def __init__(self, name, idNum, phones, features, coding="binary"):
		"""	
		name		= string for language name
		phones 		= dictionary consisting of symbol:co-ordered tuple of feature values
		features	= co-ordered list of feature names (down the road potentially make this optional if using Avery&Idsardi features)
		coding		= type of feature coding. down the road can add support for Avery&Idsardi or other systems
		"""
		self.name = name
		self._phones = phones
		self._features = features
		self._coding = coding
		
		self.idNum = idNum 
		# set of admissible hierarchies (tuples)
		# should be accessed from outside via hierarchies propery
		# since _hierarchies might be stale if feature specs are updated
		self._hierarchies = set()

		# list storing distribution of hierarchy lengths
		self._hierarchyLengths = []

		# internal variable whose value is True if new hierarchies need to be generated
		# this is done manually because generating hierarchies is computationally costly
		self._needsUpdate = True

		# print out info or not
		self.verbose = False
	@staticmethod
	def load_from_file(languagefile, idNum, coding="binary"):
		# process the file in the same way as done in existing code and return
		# language object with 
		# return Language(name, phones, features)
		# lots of room for extensibility here
		inv = d.inventoryImport(languagefile)
		feats = tuple(set([feat for key in inv.keys() for feat in inv[key]]))
		featDict = {}
		for phone in inv.keys():
			featDict[phone] = [1 if feat in inv[phone] else 0 for feat in feats]
		#print(inv)
		#print(feats)
		#print(featDict)
		return Language(languagefile[22:28], idNum, featDict, feats)
	def write_to_file(self, filename):
		pass
	def build_array(self, features):
		"""features is a subset of self._features
		returns feature array
		replacement for a dresher_lsa function
		"""
		return [tuple([self._phones[p][self._features.index(f)] for f in features]) for p in self._phones.keys()]
	@property
	def hierarchies(self):
		if self._needsUpdate:
			self._generate_hierarchies()
		return self._hierarchies
	@hierarchies.setter
	def hierarchies(self, val):
		pass
	def _generate_hierarchies(self):
		"""
		'private' method to generate allowable hierarchies based on current phones and features
		verbose = True enables old style printing
		"""

		startCombLength = int(math.ceil(math.log(len(self._phones.keys()), 2)))
		#minCombs = list(itertools.combinations(self.features, startCombLength))
		#print(len(minCombs))
		
		goodCombs=set()
		goodPerms=set()
		badPerms=set()
		lengths = [0 for i in range(len(self._phones.keys()))]
		counterTotal=0
		for length in range(startCombLength, len(self._phones.keys())+1):
			curCombs = list(itertools.combinations(self._features, length))
			for curComb in curCombs:
				# self._phones
				# self._features
				phoneFeatArray = self.build_array(curComb)
				
				# A combination of features is permissible if it distinguishes all phonemes
				# i.e. each row of the phoneFeatArray generated by the comb. must be unique
				if len(phoneFeatArray) == len(set(phoneFeatArray)):
					#add working feature set to set of sets
					goodCombs.add(frozenset(curComb))
					curPerms = list(itertools.permutations(curComb))
					for perm in curPerms:
						# immediately check for ordered containment
						try:
							for i in range(len(perm)):
								if tuple(perm[0:i+1]) in goodPerms:
									# means that there are redundant features at the tail
									#print("caught in first pass")
									#print(str(perm) + " covered by " + str(perm[0:i+1]))
									raise ValueError("Bad")
								if tuple(perm[0:i+1]) in badPerms:
									# means that there is a redundant feature within permutation
									#print("caught in first pass")
									#print(str(perm) + " " + str(perm[i+1]) + " is redundant")
									raise ValueError("Bad")
						except ValueError:
							continue
						orderedArray = self.build_array(perm)
						#print(orderedArray)
						prevNumDistinct = 1
						try:
							for i in range(len(perm)):
								curArray = [row[0:i+1] for row in orderedArray]
								curNumDistinct = len(set(curArray))
								if curNumDistinct == prevNumDistinct:
									raise ValueError("Bad")
								prevNumDistinct = curNumDistinct
						except ValueError:
							badPerms.add(tuple(perm[0:i+1]))
							#print("feature " + perm[i] + " doesn't add new information")
							#print(perm)
							continue
						#print(perm)
						#print("good")
						lengths[len(perm)] += 1
						goodPerms.add(tuple(perm))
			
				counterTotal+=1
				
				if self.verbose and counterTotal % 20 == 0: 
					# TODO fix gui updates
					gui_update = str(len(self._phones.keys()))+'-'+str(self.idNum)+"\t"+self.name+'\t'+ str(len(goodPerms))+"\t"+str(counterTotal)+"\t"+str(len(curCombs))
					print(gui_update, end='\r\033[K')
		if self.verbose:
			gui_update = str(len(self._phones.keys()))+'-'+str(self.idNum)+"\t"+self.name+'\t'+ str(len(goodPerms))+"\t"+str(counterTotal)+"\t"+str(len(curCombs))
			print(gui_update)
		self._hierarchies = goodPerms
		self._hierarchyLengths = lengths
		self._needsUpdate = False
	def min_analysis(self):
		if self._needsUpdate:
			self._generate_hierarchies()
		possibleLengths = [i for i in range(len(self._hierarchyLengths)) if self._hierarchyLengths[i] > 0]
		if self.verbose:
			print(self.name + "\t" + str(len(self._hierarchies)) + "\t" + str(min(possibleLengths)) + "\t" + str(max(possibleLengths)))
			print(self._hierarchyLengths)
		return (min(possibleLengths), max(possibleLengths))
	def efficiency_analysis(self):
		print(self.name)
		print(self._phones)
		print(self._features)
		if self._needsUpdate:
			self._generate_hierarchies()
		totalMarkedness = 0
		lowest = 0
		markednessDict = {}
		mostEfficient = set()
		for h in self._hierarchies:
			#print(h)
			spec = SDA(self._phones, self._features, h)
			#print(spec)
			markedness = sum([x for phone in spec.keys() for x in spec[phone] if x==1])
			markednessDict[markedness] = markednessDict.get(markedness, 0) + 1
			if 1.0/markedness > lowest:
				lowest = 1.0/markedness
				mostEfficient = set()
			if 1.0/markedness == lowest:
				mostEfficient.add(h)
		for k in sorted(markednessDict.keys()):
			print(k, markednessDict[k], sep=":")
		return mostEfficient
	def check_hierarchy(self, perm):
		"""method to check whether a particular hierarchy is allowable"""
		if self._needsUpdate:
			orderedArray = self.build_array(perm)
			prevNumDistinct = 1
			try:
				for i in range(len(perm)):
					curArray = [row[0:i+1] for row in orderedArray]
					curNumDistinct = len(set(curArray))
					if curNumDistinct == prevNumDistinct:
						raise ValueError("Bad")
					prevNumDistinct = curNumDistinct
			except ValueError:
				return False
			return True
		return hierarchy in self._hierarchies
	def query(self, q):
		""" query is a string of the following form
		see help in interface.py for now
		
		"""
		#regex = re.compile(r"\A(?P<exp>.*?(?= where (?P<predicate>.*))|.*)")
		#match = re.match(regex, q)
		qsp = re.split(r"\s*where\s*", q, 1)
		try:
			searchset, _ = self.query(qsp[1])
		except IndexError:
			searchset = self.hierarchies
		criteria = re.split(r"\s*>\s*", qsp[0])
		good = set()
		crit = [[f for f in re.split(r"\s*,\s*", c.strip("[]"))] for c in criteria]
		for h in searchset:
			try:
				indices = [[h.index(f) for f in c] for c in crit] 
				for x, y in zip(indices, indices[1:]):
					for i in x:
						for j in y:
							if j < i:
								raise ValueError("Bad")
			except ValueError:
				continue
			good.add(h)
		return good, len(searchset)

def SDA(phonedict, features, hierarchy):
	"""recursive SDA algorithm (only works on good permutations)
	not sure how it would handle with bad hierarchies

	#TODO should be to integrate this into the initial generation/checking process
	as it could eliminate some steps 
	"""

	set1 = [x for x in phonedict.keys() if phonedict[x][features.index(hierarchy[0])]==1]
	set2 = [x for x in phonedict.keys() if phonedict[x][features.index(hierarchy[0])]==0]

	outdict = {}
	if len(set1) == 0:
		for x in set2:
			outdict[x] = ["u"] + SDA({x:phonedict[x] for x in set2}, features, hierarchy[1:])[x]
		return outdict
	if len(set2) == 0:
		for x in set1:
			outdict[x] = ["u"] + SDA({x:phonedict[x] for x in set1}, features, hierarchy[1:])[x]
		return outdict
	if len(set1) == 1:
		outdict[set1[0]] = [1] + ["u" for _ in range(len(hierarchy)-1)]
	if len(set2) == 1:
		outdict[set2[0]] = [0] + ["u" for _ in range(len(hierarchy)-1)]
	if len(set1) > 1:
		for x in set1:
			outdict[x] = [1] + SDA({x:phonedict[x] for x in set1}, features, hierarchy[1:])[x]
	if len(set2) > 1:
		for x in set2:
			outdict[x] = [0] + SDA({x:phonedict[x] for x in set2}, features, hierarchy[1:])[x]
	return outdict

if __name__ == "__main__":
	runMain = True
	testSDA = False
	if runMain:
		# load files into language objects
		inventory_size = int(sys.argv[1])
	
		#TODO make mover function more extensible
		fileList = m.mover(inventory_size)
		#print(fileList)
		languages = []
		for i, f in enumerate(fileList):
			languages.append(Language.load_from_file(f, i+1))
		# generate hierarchies
		print("V-ct\tname\tperms\tcurIt\ttotal")
		for language in languages:
			language.verbose = True
			language.hierarchies
		# analysis
		print("lang\tperms\tmin\tmax")
		for language in languages:
			language.min_analysis()
		eff = languages[0].efficiency_analysis()
	if testSDA:
		phonedict = {"a": (1,1,1), "e": (1,0,0), "i": (0,0,1), "o": (0,0,0)}
		features = ["1", "2", "3"]
		h1 = ("1", "3")
		h2 = ("1", "2", "3")
		print(SDA(phonedict, features, h1))
		print(SDA(phonedict, features, h2))
